import HoTTModel.LocallyCartesianClosed.Basic
import HoTTModel.Lemmas.HEq

namespace CategoryTheory.LocallyCartesianClosed

open Limits Over
noncomputable section
-- homEquiv between a chosen pullback and dependent product

namespace IsPullback
variable {Œ± : Type u} [CategoryTheory.Category.{v, u} Œ±] [CategoryTheory.Limits.HasPullbacks Œ±]
  {A B C D E : Œ±} {f : A ‚ü∂ B} {fst : C ‚ü∂ D} {snd : C ‚ü∂ A} {g : D ‚ü∂ B}
  (is : IsPullback fst snd g f)

def snd_isoPullback :
    Over.mk snd ‚âÖ (f*).obj (Over.mk g) :=
  Over.isoMk is.isoPullback is.isoPullback_hom_snd

def snd_homEquiv (h : Over A) :
    (Over.mk snd ‚ü∂ h) ‚âÉ ((f*).obj (Over.mk g) ‚ü∂ h) :=
  (snd_isoPullback is).homFromEquiv

lemma snd_homEquiv_naturality {h h' : Over A} (i : Over.mk snd ‚ü∂ h) (j : h ‚ü∂ h') :
    snd_homEquiv is h' (i ‚â´ j) =  snd_homEquiv is h i ‚â´ j := by
  simp only [snd_homEquiv, Iso.homFromEquiv_apply, Category.assoc]

variable [HasFiniteWidePullbacks Œ±] [LocallyCartesianClosed Œ±]

def adjEquiv (h : Over A) :
    (Over.mk snd ‚ü∂ h) ‚âÉ (Over.mk g ‚ü∂ (Œ†f).obj h) :=
  (snd_homEquiv is h).trans ((adj f).homEquiv (Over.mk g) h)

variable (f g) in
def adjEquiv_ofHasPullback := IsPullback.adjEquiv (IsPullback.of_hasPullback g f)

@[reassoc]
lemma adjEquiv_naturality_right {h h' : Over A} (i : Over.mk snd ‚ü∂ h) (j : h ‚ü∂ h') :
    adjEquiv is h' (i ‚â´ j) = adjEquiv is h i ‚â´ (Œ†f).map j := by
  simp only [adjEquiv, Equiv.trans_apply]
  rw [snd_homEquiv_naturality is i j]
  exact Adjunction.homEquiv_naturality_right _ _ _

@[reassoc]
lemma adjEquiv_naturality_right_symm {h h' : Over A} (i : Over.mk g ‚ü∂ (Œ†f).obj h) (j : h ‚ü∂ h') :
    (adjEquiv is h').symm (i ‚â´ (Œ†f).map j) = (adjEquiv is h).symm i ‚â´ j := by
  simp only [Equiv.symm_apply_eq, adjEquiv_naturality_right,
    eq_self_iff_true, Equiv.apply_symm_apply]

section
/-
to be filled
-/
variable {C' D' : Œ±} {fst' : C' ‚ü∂ D'} {snd' : C' ‚ü∂ A} {g' : D' ‚ü∂ B}
  (is' : IsPullback fst' snd' g' f) (i : Over.mk g' ‚ü∂ Over.mk g)
  {h : Over A}

@[reassoc]
lemma adjEquiv_naturality_symm_left (j : Over.mk g ‚ü∂ (Œ†f).obj h) :
    is'.liftIsPullbackAlong' is i ‚â´ (adjEquiv is h).symm j = (adjEquiv is' h).symm (i ‚â´ j) := by
  dsimp [adjEquiv, snd_homEquiv]
  rw [Adjunction.homEquiv_naturality_left_symm, ‚Üê Category.assoc, ‚Üê Category.assoc]
  congr 1; ext; simp [snd_isoPullback]; apply pullback.hom_ext
  <;> simp

@[reassoc]
lemma adjEquiv_ofHasPullback_naturality_map_symm_left (j : Over.mk g ‚ü∂ (Œ†f).obj h) :
    (f*).map i ‚â´ (adjEquiv_ofHasPullback f g _).symm j =
      (adjEquiv_ofHasPullback f g' _).symm (i ‚â´ j) := by
  -- todo; put it somewhere else
  have : (f*).map i = (IsPullback.of_hasPullback g' f).liftIsPullbackAlong'
    (IsPullback.of_hasPullback g f) i := by
      ext
      apply (IsPullback.of_hasPullback g f).hom_ext
      <;> simp
  rw [this]
  apply adjEquiv_naturality_symm_left

@[reassoc]
lemma adjEquiv_naturality_left (j : Over.mk snd ‚ü∂ h):
    adjEquiv is' h (is'.liftIsPullbackAlong' is i ‚â´ j) = i ‚â´ adjEquiv is h j := by
  apply_fun (adjEquiv is' h).symm
  convert adjEquiv_naturality_symm_left is is' i _
  simp

end

section

variable {C' D' : Œ±} {fst' : C' ‚ü∂ D'} {snd' : C' ‚ü∂ A} {g' : D' ‚ü∂ B}
  (is' : IsPullback fst' snd' g' f) (i : Over.mk g' ‚ü∂ Over.mk g)
  {h : Over A} (j : Over.mk g ‚ü∂ (Œ†f).obj h)

@[reassoc]
lemma adjEquiv_naturality_symm_left' :
    is'.liftIsPullbackAlong' (IsPullback.of_hasPullback g f) i ‚â´
      ((adj f).homEquiv (Over.mk g) h).symm j = (adjEquiv is' h).symm (i ‚â´ j) := by
    dsimp [adjEquiv, snd_homEquiv]
    rw [Adjunction.homEquiv_naturality_left_symm, ‚Üê Category.assoc]
    congr 1; ext; simp [snd_isoPullback]; apply pullback.hom_ext
    <;> simp

end

section

-- eq on `g` gives `heq`

variable {g' : D ‚ü∂ B} (eq : g = g')

def adjEquiv_eqToHom_comp_isPullback :
  IsPullback fst snd g' f  := by
  cases eq; exact is

lemma adjEquiv_eqToHom_comp (h : Over A) (j : Over.mk snd ‚ü∂ h):
  HEq (adjEquiv is h j) (adjEquiv (adjEquiv_eqToHom_comp_isPullback is eq) h j) := by
  cases eq
  rfl

end

end IsPullback
end

noncomputable section
/-
Consider
` A -- i --> A'`
` |          | `
` f          f'`
` ‚Üì          ‚Üì `
` B -- j --> B'`
` |          | `
` g          g'`
` ‚Üì          ‚Üì `
` C -- k --> C `
` |          | `
` ‚Üë          ‚Üë `
` |          | `
`Œ†A -- ? --> Œ†A'`
with the top two squares are pullback, can exhibit a pullback square down in the botto
-/

variable {Œ± : Type u} [CategoryTheory.Category.{v, u} Œ±]
  [HasFiniteWidePullbacks Œ±] [LocallyCartesianClosed Œ±]
  {A A' B B' C C' : Œ±} {f : A ‚ü∂ B} {g : B ‚ü∂ C} {f' : A' ‚ü∂ B'} {g' : B' ‚ü∂ C'}
  {k : C ‚ü∂ C'} {j : B ‚ü∂ B'} {i : A ‚ü∂ A'}
  (is : IsPullback j g g' k) (comm : CommSq i f f' j)

def pushforward.trans‚ÇÄ :
    (Œ£k).obj ((Œ†g).obj (Over.mk f)) ‚ü∂ (Œ†g').obj (Over.mk f') := by
  refine IsPullback.adjEquiv
    (IsPullback.paste_vert (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g) is.flip)
    (Over.mk f') ?_
  refine Over.homMk (((IsPullback.adjEquiv_ofHasPullback g ((Œ†g).obj (Over.mk f)).hom _).symm
    (ùüô _)).left ‚â´ i) ?_
  simp; erw [comm.w, ‚Üê Category.assoc, Over.w]; rfl

abbrev pushforward.trans :
    ((Œ†g).obj (Over.mk f)).left ‚ü∂ ((Œ†g').obj (Over.mk f')).left :=
  (pushforward.trans‚ÇÄ is comm).left

variable {E : Over C} {q : E ‚ü∂ ((Œ†g).obj (Over.mk f))}

lemma pushforward.comp_trans‚ÇÄ :
  (Œ£k).map q ‚â´ pushforward.trans‚ÇÄ is comm = IsPullback.adjEquiv
    ((IsPullback.of_hasPullback E.hom g).paste_vert is.flip) _
    ((Œ£j).map (((g*).map q) ‚â´
    (IsPullback.adjEquiv_ofHasPullback g ((Œ†g).obj (Over.mk f)).hom _).symm (ùüô _)) ‚â´
    (homMk i comm.w : Over.mk (f ‚â´ j) ‚ü∂ Over.mk f')) := by
  let is‚ÇÄ := (IsPullback.of_hasPullback E.hom g).paste_vert is.flip
  let is‚ÇÅ := IsPullback.paste_vert
    (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g) is.flip
  apply_fun (IsPullback.adjEquiv is‚ÇÄ (Over.mk f')).symm
  simp only [Equiv.symm_apply_apply, trans‚ÇÄ]
  rw [‚Üê IsPullback.adjEquiv_naturality_left is‚ÇÅ is‚ÇÄ]
  ext; simp;
  congr 1
  apply is‚ÇÅ.hom_ext
  <;> simp

lemma pushforward.comp_trans‚ÇÄ' {F : Œ±} {l : F ‚ü∂ E.left} {m : F ‚ü∂ B}
  (is' : IsPullback l m E.hom g) :
  (Œ£k).map q ‚â´ pushforward.trans‚ÇÄ is comm = IsPullback.adjEquiv (is'.paste_vert is.flip) _
      ((Œ£j).map ((is'.liftIsPullbackAlong'
      (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g) q) ‚â´
      (IsPullback.adjEquiv_ofHasPullback g ((Œ†g).obj (Over.mk f)).hom _).symm (ùüô _)) ‚â´
      (homMk i comm.w : Over.mk (f ‚â´ j) ‚ü∂ Over.mk f')) := by
  let is‚ÇÄ := is'.paste_vert is.flip
  let is‚ÇÅ := IsPullback.paste_vert
    (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g) is.flip
  apply_fun (IsPullback.adjEquiv is‚ÇÄ (Over.mk f')).symm
  simp only [Equiv.symm_apply_apply, trans‚ÇÄ]
  rw [‚Üê IsPullback.adjEquiv_naturality_left is‚ÇÅ is‚ÇÄ]
  ext; simp;
  congr 1
  apply is‚ÇÅ.hom_ext
  <;> simp
  rw [IsPullback.liftIsPullbackAlong_snd_assoc]

section

variable (is' : IsPullback i f f' j) (t : PullbackCone ((Œ†g').obj (Over.mk f')).hom k)
def pushforward.isPullbackLift‚ÇÄ :
    Over.mk t.snd ‚ü∂ (Œ†g).obj (Over.mk f) := by
  let v := (IsPullback.adjEquiv
    (IsPullback.paste_vert (IsPullback.of_hasPullback t.snd g) is.flip)
    _).symm (Over.homMk t.fst t.condition)
  exact IsPullback.adjEquiv_ofHasPullback g t.snd _
    $ Over.homMk (is'.lift v.left (pullback.snd t.snd g) (Over.w v)) (is'.lift_snd _ _ _)

abbrev pushforward.isPullbackLift :
    t.pt ‚ü∂ ((Œ†g).obj (Over.mk f)).left :=
  (isPullbackLift‚ÇÄ is is' t).left

attribute [-simp] PullbackCone.œÄ_app_right

lemma pushforward.isPullbackLift_fst :
    isPullbackLift is is' t ‚â´ (pushforward.trans is is'.toCommSq) = t.fst := by
  simp [trans]
  let t' : Over.mk (t.snd ‚â´ k) ‚ü∂ ((Œ†g').obj (Over.mk f')) := Over.homMk t.fst t.condition
  let lift := (Œ£k).map (isPullbackLift‚ÇÄ is is' t)
  change lift.left ‚â´ _ =  t'.left
  rw [‚Üê comp_left, pushforward.comp_trans‚ÇÄ]; congr
  apply_fun (IsPullback.adjEquiv
    (IsPullback.paste_vert (IsPullback.of_hasPullback _ g) is.flip) (Over.mk f')).symm
  rw [Equiv.symm_apply_apply]
  ext; simp only [comp_left, map_map_left, t', homMk_left, ‚Üê Category.assoc]
  rw [‚Üê comp_left, IsPullback.adjEquiv_ofHasPullback_naturality_map_symm_left,
      Category.comp_id]
  simp [isPullbackLift‚ÇÄ, Equiv.symm_apply_apply, homMk_left, is'.lift_fst]

def pushforward.isPullback :
    IsPullback (trans is is'.toCommSq) ((Œ†g).obj (Over.mk f)).hom
      ((Œ†g').obj (Over.mk f')).hom k where
    w := by simp
    isLimit' := ‚ü®by
      apply PullbackCone.isLimitAux _ (isPullbackLift is is')
      . intro; apply isPullbackLift_fst
      . intro; exact Over.w _
      . intro s w h
        change (Over.homMk w (h WalkingCospan.right)).left = (isPullbackLift‚ÇÄ is is' s).left
        congr 1
        apply_fun (IsPullback.adjEquiv_ofHasPullback g s.snd _).symm
        simp only [isPullbackLift‚ÇÄ, Equiv.symm_apply_apply]
        let w‚ÇÄ : Over.mk s.snd ‚ü∂ ((Œ†g).obj (Over.mk f)) := homMk w (h WalkingCospan.right)
        let w' := (IsPullback.adjEquiv_ofHasPullback g s.snd (Over.mk f)).symm w‚ÇÄ
        ext; simp only [homMk_left]
        apply is'.hom_ext
        . let i' : Over.mk (f ‚â´ j) ‚ü∂ Over.mk f' := Over.homMk i is'.w
          let is‚ÇÄ := IsPullback.paste_vert (IsPullback.of_hasPullback s.snd g) is.flip
          let is‚ÇÅ := IsPullback.paste_vert
            (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g) is.flip
          have : (Œ£k).map w‚ÇÄ ‚â´ (trans‚ÇÄ is is'.toCommSq) = Over.homMk s.fst s.condition := by
            ext; exact h WalkingCospan.left
          change ((Œ£j).map w').left ‚â´ i'.left = _
          rw [IsPullback.lift_fst, ‚Üê comp_left]
          congr 1
          rw [‚Üê (IsPullback.adjEquiv is‚ÇÄ (Over.mk f')).apply_eq_iff_eq_symm_apply, ‚Üê this]
          dsimp only [trans‚ÇÄ]
          rw [‚Üê IsPullback.adjEquiv_naturality_left is‚ÇÅ is‚ÇÄ]
          congr 1; ext
          simp only [comp_left, homMk_left, map_map_left, i', ‚Üê Category.assoc, w']
          congr 1
          have : (is‚ÇÄ.liftIsPullbackAlong' is‚ÇÅ ((Œ£k).map w‚ÇÄ)).left =
            ((g*).map w‚ÇÄ).left := by
              apply is‚ÇÅ.hom_ext
              . simp only [IsPullback.liftIsPullbackAlong', homMk_left, Over.pullback]
                rw [is‚ÇÄ.liftIsPullbackAlong_fst, pullback.lift_fst]; rfl
              . simp only [IsPullback.liftIsPullbackAlong', homMk_left, Over.pullback]
                rw [is‚ÇÄ.liftIsPullbackAlong_snd, pullback.lift_snd_assoc]; rfl
          rw [this, ‚Üê comp_left, IsPullback.adjEquiv_ofHasPullback_naturality_map_symm_left,
              Category.comp_id]
        . erw [Over.w, IsPullback.lift_snd]; rfl
    ‚ü©
end

section
variable (is' : IsPullback i f f' j) {D D' E E' : Œ±} {d : D ‚ü∂ D'} {p : D ‚ü∂ C} {p' : D' ‚ü∂ C'}
  {q : E ‚ü∂ B} {q' : E' ‚ü∂ B'} {t : E ‚ü∂ D} {t' : E' ‚ü∂ D'}
  (is‚ÇÅ : IsPullback t q p g) (is‚ÇÇ : IsPullback t' q' p' g') (comm : CommSq d p p' k)

abbrev pushforward.liftAux :
    E ‚ü∂ E' :=
  (is‚ÇÅ.paste_vert is.flip).liftIsPullbackAlong is‚ÇÇ d comm.w

abbrev pushforward.liftAux' :
    Over.mk (q ‚â´ j) ‚ü∂ Over.mk q' :=
  (is‚ÇÅ.paste_vert is.flip).liftIsPullbackAlong' is‚ÇÇ (Over.homMk d comm.w)

def pushforward.commSqAux :
    CommSq (liftAux is is‚ÇÅ is‚ÇÇ comm) q q' j where
  w := by simp

lemma pushforward.adj_symm_comp (b : Over.mk p' ‚ü∂ (Œ†g').obj (Over.mk f')) :
  ((IsPullback.adjEquiv is‚ÇÅ _).symm
    (comm.liftIsPullbackAlong' (pushforward.isPullback is is') b)).left ‚â´ i =
    liftAux is is‚ÇÅ is‚ÇÇ comm ‚â´ ((IsPullback.adjEquiv is‚ÇÇ (Over.mk f')).symm b).left := by
  let bk := (Œ£k).map (comm.liftIsPullbackAlong' (pushforward.isPullback is is') b)
  let b' := is‚ÇÅ.liftIsPullbackAlong' (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g)
    (comm.liftIsPullbackAlong' (pushforward.isPullback is is') b)
  let d' : Over.mk (p ‚â´ k) ‚ü∂ Over.mk p' := Over.homMk d comm.w
  let cj := (Œ£j).map ((IsPullback.adjEquiv is‚ÇÅ _).symm
    (comm.liftIsPullbackAlong' (pushforward.isPullback is is') b))
  let cj' := (is‚ÇÅ.paste_vert is.flip).liftIsPullbackAlong'
    ((IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g).paste_vert is.flip) bk
  let i' : Over.mk (f ‚â´ j) ‚ü∂ Over.mk f' := Over.homMk i is'.w
  let counitj := (Œ£j).map
    ((IsPullback.adjEquiv_ofHasPullback g ((Œ†g).obj (Over.mk f)).hom _).symm (ùüô _))
  have aux‚ÇÄ : (Œ£j).map b' = cj' := by
    ext; simp [cj', b']
    apply ((IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g).paste_vert is.flip).hom_ext
    . simp [bk]
    . simp [bk]; rw [‚Üê Category.assoc, IsPullback.liftIsPullbackAlong_snd]
  have aux‚ÇÅ : cj = cj' ‚â´ counitj := by
    simp [counitj, ‚Üê aux‚ÇÄ, cj]
    erw [‚Üê Functor.map_comp, IsPullback.adjEquiv_naturality_symm_left, Category.comp_id]
    rfl
  have aux‚ÇÇ : d' ‚â´ b = bk ‚â´ trans‚ÇÄ is is'.toCommSq := by ext; simp [d', bk]
  change cj.left ‚â´ i'.left = (liftAux' is is‚ÇÅ is‚ÇÇ comm).left ‚â´ _
  rw [‚Üê comp_left, ‚Üê comp_left, IsPullback.adjEquiv_naturality_symm_left, aux‚ÇÅ, aux‚ÇÇ,
    Category.assoc]
  congr
  apply_fun (IsPullback.adjEquiv (is‚ÇÅ.paste_vert is.flip) (Over.mk f'))
  rw [Equiv.apply_symm_apply, IsPullback.adjEquiv_naturality_left]; rfl

lemma pushforward.adj_symm_lift_eq_lift_adj_symm (b : Over.mk p' ‚ü∂ (Œ†g').obj (Over.mk f')) :
  (IsPullback.adjEquiv is‚ÇÅ _).symm
    (comm.liftIsPullbackAlong' (pushforward.isPullback is is') b) =
      (pushforward.commSqAux is is‚ÇÅ is‚ÇÇ comm).liftIsPullbackAlong' is'
        ((IsPullback.adjEquiv is‚ÇÇ _).symm b) := by
  ext; apply is'.hom_ext
  . simp; apply pushforward.adj_symm_comp (is' := is')
  . simpa using Over.w _

lemma pushforward.adj_lift_eq_lift_adj (a : Over.mk q' ‚ü∂ Over.mk f') :
    comm.liftIsPullbackAlong' (pushforward.isPullback is is') (IsPullback.adjEquiv is‚ÇÇ _ a) =
      IsPullback.adjEquiv is‚ÇÅ _
        ((pushforward.commSqAux is is‚ÇÅ is‚ÇÇ comm).liftIsPullbackAlong' is' a) := by
  apply_fun (IsPullback.adjEquiv is‚ÇÅ _).symm
  convert adj_symm_lift_eq_lift_adj_symm is is' is‚ÇÅ is‚ÇÇ comm (IsPullback.adjEquiv is‚ÇÇ _ a)
  simp only [Equiv.symm_apply_apply]

end

section
/-
Consider
` A -- i --> A'-- i' --> A''`
` |          |            | `
` f          f'          f''`
` ‚Üì          ‚Üì            ‚Üì `
` B -- j --> B' -- j' --> B''`
` |          |            | `
` g          g'          g''`
` ‚Üì          ‚Üì            ‚Üì`
` C -- k --> C' -- k' --> C'' `
` |          |            |`
` ‚Üë          ‚Üë            ‚Üë`
` |          |            |`
`Œ†A -------> Œ†A'-------> Œ†A''`
-/

variable {A'' B'' C'' : Œ±} {f'' : A'' ‚ü∂ B''} {g'' : B'' ‚ü∂ C''}
  {i' : A' ‚ü∂ A''} {j' : B' ‚ü∂ B''} {k' : C' ‚ü∂ C''}
  (is' : IsPullback j' g' g'' k') (comm' : CommSq i' f' f'' j')

@[reassoc]
lemma pushforward.trans_comp :
    pushforward.trans is comm ‚â´ pushforward.trans is' comm' =
      pushforward.trans (is.paste_horiz is') (comm.horiz_comp comm') := by
  have eq : (Œ£k').obj ((Œ£k).obj ((Œ†g).obj (Over.mk f))) =
    (Œ£k ‚â´ k').obj ((Œ†g).obj (Over.mk f)) := by
      rw [mapComp_eq]; rfl
  let is‚ÇÅ := (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g).paste_vert is.flip
  let is‚ÇÇ := is‚ÇÅ.paste_vert is'.flip
  have eq : (((Œ†g).obj (Over.mk f)).hom ‚â´ k) ‚â´ k' = ((Œ†g).obj (Over.mk f)).hom ‚â´ k ‚â´ k' := by
    simp
  let is‚ÇÇ' := IsPullback.adjEquiv_eqToHom_comp_isPullback is‚ÇÇ eq
  let is‚ÇÇ'' := (IsPullback.of_hasPullback ((Œ†g).obj (Over.mk f)).hom g).paste_vert
    (is.flip.paste_vert is'.flip)
  let l := is‚ÇÇ'.liftIsPullbackAlong' is‚ÇÇ'' (ùüô _)
  have : l.left = ùüô _ := by
    apply is‚ÇÇ''.hom_ext
    <;> simp [l]
  simp only [trans]
  change ((Œ£k').map (trans‚ÇÄ is comm)).left ‚â´ _ = _
  rw [‚Üê comp_left]
  congr 1
  rw [comp_trans‚ÇÄ' _ _ is‚ÇÅ]
  let ev := (IsPullback.adjEquiv_ofHasPullback g ((Œ†g).obj (Over.mk f)).hom _).symm (ùüô _)
  let evj' := (Œ£(j ‚â´ j')).map ev
  let ev' := (IsPullback.adjEquiv_ofHasPullback g' ((Œ†g').obj (Over.mk f')).hom _).symm (ùüô _)
  let i_ : Over.mk (f ‚â´ j ‚â´ j') ‚ü∂ Over.mk (f' ‚â´ j') := Over.homMk i (by simp [comm.w_assoc])
  have aux : (Œ£j').map ((is‚ÇÅ.liftIsPullbackAlong'
    (IsPullback.of_hasPullback ((Œ†g').obj (Over.mk f')).hom g') (trans‚ÇÄ is comm)) ‚â´ ev') =
      l ‚â´ evj' ‚â´ i_ := by
    erw [IsPullback.adjEquiv_naturality_symm_left]
    rw [Category.comp_id]
    ext
    simp [comp_left, this, trans‚ÇÄ]; rfl
  refine HEq.trans ((IsPullback.adjEquiv_eqToHom_comp is‚ÇÇ eq) _ _) ?_
  simp_rw [aux, Category.assoc]
  rw [IsPullback.adjEquiv_naturality_left]
  simp
  rfl
end
end
